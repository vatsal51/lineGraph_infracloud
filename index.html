<!DOCTYPE html>
<html>

<head>
  <title>Line Chart</title>
  <!-- Include Chart.js library -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<script src="https://cdn.jsdelivr.net/npm/date-fns@2.23.0"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css">
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.js"></script>

<body>
  <p id="chartError" style="color: red; display: none;">No data available for the selected date range.</p>
  <canvas id="lineChart" width="800" height="400"></canvas>
  <!-- <button id="timeRangeFilter">Filter by Time Range</button> -->
  <button id="specialEndpointFilter">Filter Special Endpoints</button>
  <input type="text" id="dateRangePicker" placeholder="Select date range">
  <!-- Add a "Reset" button -->
  <button id="resetChart">Reset Chart</button>
</body>
<script>

  const data = [
    { endpoint: "/home", time: '2023-10-08T02:18:17.735Z', requests: 2364, special: true },
    { endpoint: "/home", time: '2023-10-07T02:23:17.735Z', requests: 1132 },
    { endpoint: "/home", time: '2023-10-06T02:03:17.735Z', requests: 3433, special: true },
    { endpoint: "/product", time: '2023-10-07T02:13:17.735Z', requests: 1563 },
    { endpoint: "/product", time: '2023-10-06T02:12:17.735Z', requests: 1563 },
    { endpoint: "/contact", time: '2023-10-07T02:13:17.735Z', requests: 2298, special: true },
    { endpoint: "/product", time: '2023-10-08T02:17:17.735Z', requests: 3198, special: true },
    { endpoint: "/contact", time: '2023-10-08T02:13:17.735Z', requests: 1950, special: true },
    { endpoint: "/contact", time: '2023-10-06T02:01:17.735Z', requests: 2800 },
  ];

  function color(index) {
    let borderColor = 'blue'; // Default color
    if (index === 1) {
      borderColor = 'red';
    } else if (index === 2) {
      borderColor = 'green';
    }
    return borderColor
  }
  // Create objects to store the split data
  const dataMap = {};

  // Iterate through the data and split it based on the endpoint
  data.forEach(item => {
    if (!dataMap[item.endpoint]) {
      dataMap[item.endpoint] = [];
    }
    dataMap[item.endpoint].push(item);
  });

  // Convert the dataMap into an array of arrays
  const result = Object.values(dataMap);

  // Now result contains the split data based on the endpoint
  console.log(result);

  const ctx = document.getElementById('lineChart').getContext('2d');

  const config_data = {
    labels: result[0].map(item => item.time),
    datasets: result.map((endpointData, index) => {


      return {
        label: endpointData[0].endpoint,
        data: endpointData.map(item => item.requests),
        borderColor: color(index),
        fill: false,
        // tension: 0.4
      };
    }),
  };

  // Now we have the chart configuration in config_data with datasets for each endpoint
  console.log(config_data);

  const chartConfig = {
    type: 'line',
    data: config_data,
    respossive: true
  };

  const lineChart = new Chart(ctx, chartConfig);

  // Implement user-friendly features


  // Initialize the date range picker
  $('#dateRangePicker').daterangepicker({
    opens: 'left',
    autoApply: true,
    locale: {
      format: 'YYYY-MM-DD', // Specify the date format
    },
  });



  $('#dateRangePicker').on('apply.daterangepicker', function (ev, picker) {
    const startDate = picker.startDate.toDate();
    const endDate = picker.endDate.toDate();

    // Filter data for the selected time range
    const filteredData = data.filter(item => {
      const itemDate = new Date(item.time);
      return itemDate >= startDate && itemDate <= endDate;
    });

    // Check if there's no data in the filtered result
    if (filteredData.length === 0) {
      // Display an error message or perform any other desired action
      alert("No data available for the selected date range.");

      // Remove the plotted graph
      lineChart.data.labels = [];
      lineChart.data.datasets = [];
    } else {
      // Split the filtered data based on endpoints
      const filteredDataMap = {};

      filteredData.forEach(item => {
        if (!filteredDataMap[item.endpoint]) {
          filteredDataMap[item.endpoint] = [];
        }
        filteredDataMap[item.endpoint].push(item);
      });

      // Update the chart with the filtered data
      const filteredResult = Object.values(filteredDataMap);
      lineChart.data.labels = filteredResult[0].map(item => item.time);
      lineChart.data.datasets = filteredResult.map((endpointData, index) => ({
        label: endpointData[0].endpoint,
        data: endpointData.map(item => item.requests),
        borderColor: getRandomColor(),
        fill: false,
      }));
    }

    lineChart.update();
  });



  document.getElementById('specialEndpointFilter').addEventListener('click', () => {
    // Filter data to include only items where 'special' is true
    const filteredData = data.filter(item => item.special === true);

    // Create a map of unique endpoints and their corresponding data
    const endpointMap = new Map();

    filteredData.forEach(item => {
      if (!endpointMap.has(item.endpoint)) {
        endpointMap.set(item.endpoint, []);
      }
      endpointMap.get(item.endpoint).push(item);
    });

    // Update the chart to display the filtered data for each endpoint

    const updatedDatasets = Array.from(endpointMap.values()).map((endpointData, index) => ({
      label: endpointData[0].endpoint,
      data: endpointData.map(item => item.requests),
      borderColor: color(index), // Generate a random color for each endpoint
      fill: false,
      // tension: 0.4
    }));

    lineChart.data.labels = filteredData.map(item => item.time);
    lineChart.data.datasets = updatedDatasets;

    lineChart.update();
  });


  // Store the original chart data when it is initially loaded
  const originalData = {
    labels: lineChart.data.labels,
    datasets: lineChart.data.datasets,
  };

  function reset() {
    lineChart.data.labels = originalData.labels;
    lineChart.data.datasets = originalData.datasets;
    lineChart.update();
  }
  // Add an event listener for the "Reset Chart" button
  document.getElementById('resetChart').addEventListener('click', () => {
    // Restore the original data to reset the chart
    reset();
  });


</script>

</html>